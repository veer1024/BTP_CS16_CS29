The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))
The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 The first thing we are going to do is importing the AES module from the pycrypto library. This module will provide the functions and classes we need to both encrypt and decrypt the data.
1
	
from Crypto.Cipher import AES

Next we need to set our secret encryption key. Since AES is a symmetric encrypton algorithm, the key is private and needs to be known only by the two communicating parties.

The length of the key needs to be 16, 24 or 32 bytes long, depending if we want to use AES-128, AES-192 or AES-256 respectively [3], as we have mentioned in the introduction.

We are going to choose an arbitrary 16 bytes key just for illustrations purposes. Note that the key chosen is not secure at all and for real scenario use cases you should use strong keys.
1
	
key = 'abcdefghijklmnop'

Next we need to call the new function of the AES module. This function  will return an object of class AESCipher [4], which provides the functions to both encrypt and decrypt the data.

This function has many optional parameters that you can check here, but we are only going to use the key and mode parameters.

The key parameter corresponds to the encryption key to be used by the algorithm and we will pass it the key we previously defined [4].

The mode parameter corresponds to the chaining mode that is used for decryption / encryption [4]. We are going to pass the value MODE_ECB, to use the electronic code book mode.
1
	
cipher = AES.new(key, AES.MODE_ECB)

Now that we have our AESCipher object, we can encrypt the data with a call to the encrypt method. As input, this method receives the plain text string and encrypts it with the provided key and configurations used in the new function call.

Remember that the length of the message to encrypt needs to be a multiple of the block size, which is 16 bytes. In this case, the plain text message I’m passing has 32 bytes and the first block is equal to the second, to later illustrate the pattern repetition on the ciphered text, from using the ECB mode.

This encrypt method call will return as output a string with the cipher text. We will also print the type of the returned value to confirm it is indeed a string.
1
2
	
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))

To make the result more user friendly, we will convert the cipher text to its hexadecimal representation. To do it, we call the encode method on our cipher text string, passing the value “hex” as input.
1
	
print(msg.encode("hex"))

Now that we have our cipher text, we will decrypt it back to plain text. Note that since the cipher object we have created before is stateful [5], we should create a new one for decryption calling the new function again, with the same input parameters.
1
	
decipher = AES.new(key, AES.MODE_ECB)

Finally, we call the decrypt method on our new object, passing as input the ciphered text. It returns as output the original decrypted plain text, which we will print.
1
	
print(decipher.decrypt(msg))

The final source code can be seen below.
1
2
3
4
5
6
7
8
9
10
11
12
	
from Crypto.Cipher import AES
 
key = 'abcdefghijklmnop'
 
cipher = AES.new(key, AES.MODE_ECB)
msg =cipher.encrypt('TechTutorialsX!!TechTutorialsX!!')
print (type(msg))
 
print(msg.encode("hex"))
 
decipher = AES.new(key, AES.MODE_ECB)
print(decipher.decrypt(msg))

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 

Testing the code

To test the code, simply run it on your Python environment of choice. I’m using IDLE, the  IDE that comes by default with the Python installation.

You should get an output similar to figure 1, which shows the results of running the program. The first thing we can see is that the output of the encrypt method is indeed a string.

Then, we can check the cipher text resulting from encrypting the input plain text. I’ve highlighted the two blocks of the cipher text and, as can be seen, they are equal because the originating blocks of plain text were also equal. This illustrates the problem of using ECB and why we should use stronger modes.

Finally, we can check the the decryption result, obtained from using the same key.

Python pycripto AES 128 ECB mode.png

Figure 1 – Output of the program.

References

[1] https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf

[2] https://proandroiddev.com/security-best-practices-symmetric-encryption-with-aes-in-java-7616beaaade9

[3] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html

[4] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.AES-module.html#new

[5] https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo.BlockAlgo-class.html#encrypt

 
